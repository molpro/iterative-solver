<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>iterative-solver: molpro::linalg::itsolv::LinearEigensystemDavidson&lt; R, Q, P &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">iterative-solver<span id="projectnumber">&#160;0.0</span>
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">molpro::linalg::itsolv::LinearEigensystemDavidson&lt; R, Q, P &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>One specific implementation of <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystem.html" title="Interface for a specific iterative solver, it can add special member functions or variables.">LinearEigensystem</a> using Davidson's algorithm with modifications to manage near linear dependencies, and consequent numerical noise, in candidate expansion vectors.  
 <a href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="LinearEigensystemDavidson_8h_source.html">LinearEigensystemDavidson.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for molpro::linalg::itsolv::LinearEigensystemDavidson&lt; R, Q, P &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson__inherit__graph.png" border="0" usemap="#amolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson_3_01R_00_01Q_00_01P_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="amolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson_3_01R_00_01Q_00_01P_01_4_inherit__map" id="amolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson_3_01R_00_01Q_00_01P_01_4_inherit__map">
<area shape="rect" title="One specific implementation of LinearEigensystem using Davidson&#39;s algorithm with modifications to man..." alt="" coords="813,20,1028,76"/>
<area shape="rect" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html" title=" " alt="" coords="555,5,765,91"/>
<area shape="rect" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystem.html" title=" " alt="" coords="280,13,507,83"/>
<area shape="rect" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html" title=" " alt="" coords="5,13,232,83"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for molpro::linalg::itsolv::LinearEigensystemDavidson&lt; R, Q, P &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson__coll__graph.png" border="0" usemap="#amolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson_3_01R_00_01Q_00_01P_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="amolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson_3_01R_00_01Q_00_01P_01_4_coll__map" id="amolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson_3_01R_00_01Q_00_01P_01_4_coll__map">
<area shape="rect" title="One specific implementation of LinearEigensystem using Davidson&#39;s algorithm with modifications to man..." alt="" coords="953,91,1168,147"/>
<area shape="rect" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html" title=" " alt="" coords="561,5,772,91"/>
<area shape="rect" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystem.html" title=" " alt="" coords="281,13,508,83"/>
<area shape="rect" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html" title=" " alt="" coords="5,13,232,83"/>
<area shape="rect" href="classmolpro_1_1linalg_1_1itsolv_1_1detail_1_1DSpaceResetter.html" title=" " alt="" coords="557,115,776,157"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class R, class Q = R, class P = std::map&lt;size_t, typename R::value_type&gt;&gt;<br />
class molpro::linalg::itsolv::LinearEigensystemDavidson&lt; R, Q, P &gt;</div><p >One specific implementation of <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystem.html" title="Interface for a specific iterative solver, it can add special member functions or variables.">LinearEigensystem</a> using Davidson's algorithm with modifications to manage near linear dependencies, and consequent numerical noise, in candidate expansion vectors. </p>
<p >TODO add more documentation and examples</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td></td></tr>
    <tr><td class="paramname">Q</td><td></td></tr>
    <tr><td class="paramname">P</td><td></td></tr>
  </table>
  </dd>
</dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae0ec3d737bc94543b35dc4d0e3558470"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#ae0ec3d737bc94543b35dc4d0e3558470">SolverTemplate</a> = <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html">IterativeSolverTemplate</a>&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystem.html">LinearEigensystem</a>, R, Q, P &gt;</td></tr>
<tr class="separator:ae0ec3d737bc94543b35dc4d0e3558470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html">molpro::linalg::itsolv::IterativeSolver&lt; R, R, std::map&lt; size_t, typename R::value_type &gt; &gt;</a></td></tr>
<tr class="memitem:a027b41582a1fff9ebb679e6ae6e2fe5f inherit pub_types_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a027b41582a1fff9ebb679e6ae6e2fe5f">value_type</a> = typename R::value_type</td></tr>
<tr class="memdesc:a027b41582a1fff9ebb679e6ae6e2fe5f inherit pub_types_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">The underlying type of elements of vectors.  <a href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a027b41582a1fff9ebb679e6ae6e2fe5f">More...</a><br /></td></tr>
<tr class="separator:a027b41582a1fff9ebb679e6ae6e2fe5f inherit pub_types_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ce4d7778dab44edee1bea7075d7f227 inherit pub_types_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a4ce4d7778dab44edee1bea7075d7f227">scalar_type</a> = typename <a class="el" href="classmolpro_1_1linalg_1_1array_1_1ArrayHandler.html">array::ArrayHandler</a>&lt; R, R &gt;<a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a027b41582a1fff9ebb679e6ae6e2fe5f">::value_type</a></td></tr>
<tr class="separator:a4ce4d7778dab44edee1bea7075d7f227 inherit pub_types_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17dcf15a66ef5c759d8a8a9a5616ce92 inherit pub_types_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a17dcf15a66ef5c759d8a8a9a5616ce92">value_type_abs</a> = typename <a class="el" href="classmolpro_1_1linalg_1_1array_1_1ArrayHandler.html">array::ArrayHandler</a>&lt; R, R &gt;::value_type_abs</td></tr>
<tr class="separator:a17dcf15a66ef5c759d8a8a9a5616ce92 inherit pub_types_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83cc580bb3f1dfab899fa9b4cd68babf inherit pub_types_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a83cc580bb3f1dfab899fa9b4cd68babf">VectorP</a> = std::vector&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a027b41582a1fff9ebb679e6ae6e2fe5f">value_type</a> &gt;</td></tr>
<tr class="separator:a83cc580bb3f1dfab899fa9b4cd68babf inherit pub_types_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64287edfda9bc2abbdafd958b6cfe682 inherit pub_types_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a64287edfda9bc2abbdafd958b6cfe682">fapply_on_p_type</a> = std::function&lt; void(const std::vector&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a83cc580bb3f1dfab899fa9b4cd68babf">VectorP</a> &gt; &amp;, const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#aafd1821a97ea122d56be347e38e90a89">CVecRef</a>&lt; std::map&lt; size_t, typename R::value_type &gt; &gt; &amp;, const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ab44c7c7dfce88d39d260d1f5c7b70fab">VecRef</a>&lt; R &gt; &amp;)&gt;</td></tr>
<tr class="separator:a64287edfda9bc2abbdafd958b6cfe682 inherit pub_types_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae1fcec228a6eaf28bab62636828e5483"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#ae1fcec228a6eaf28bab62636828e5483">LinearEigensystemDavidson</a> (const std::shared_ptr&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1ArrayHandlers.html">ArrayHandlers</a>&lt; R, Q, P &gt; &gt; &amp;handlers=std::make_shared&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1ArrayHandlers.html">molpro::linalg::itsolv::ArrayHandlers</a>&lt; R, Q, P &gt; &gt;(), const std::shared_ptr&lt; <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1Logger.html">Logger</a> &gt; &amp;logger_=std::make_shared&lt; <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1Logger.html">Logger</a> &gt;())</td></tr>
<tr class="separator:ae1fcec228a6eaf28bab62636828e5483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a262897f82aa5a3ed099646e05ab73372"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#a262897f82aa5a3ed099646e05ab73372">nonlinear</a> () const override</td></tr>
<tr class="memdesc:a262897f82aa5a3ed099646e05ab73372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report whether the class is a non-linear solver.  <a href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#a262897f82aa5a3ed099646e05ab73372">More...</a><br /></td></tr>
<tr class="separator:a262897f82aa5a3ed099646e05ab73372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22ed76de01c073008465614a389df5c3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#a22ed76de01c073008465614a389df5c3">end_iteration</a> (const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ab44c7c7dfce88d39d260d1f5c7b70fab">VecRef</a>&lt; R &gt; &amp;parameters, const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ab44c7c7dfce88d39d260d1f5c7b70fab">VecRef</a>&lt; R &gt; &amp;action) override</td></tr>
<tr class="memdesc:a22ed76de01c073008465614a389df5c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proposes new parameters for the subspace from the preconditioned residuals.  <a href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#a22ed76de01c073008465614a389df5c3">More...</a><br /></td></tr>
<tr class="separator:a22ed76de01c073008465614a389df5c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f3c0bb3e790c82ffebbfbe62d1d3a9c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#a5f3c0bb3e790c82ffebbfbe62d1d3a9c">end_iteration</a> (std::vector&lt; R &gt; &amp;parameters, std::vector&lt; R &gt; &amp;action) override</td></tr>
<tr class="separator:a5f3c0bb3e790c82ffebbfbe62d1d3a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebcf854909acb92f11bb2ea33a596c64"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#aebcf854909acb92f11bb2ea33a596c64">end_iteration</a> (R &amp;parameters, R &amp;actions) override</td></tr>
<tr class="separator:aebcf854909acb92f11bb2ea33a596c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66a707d2bc8900f8b0478c881ef99cf4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#a66a707d2bc8900f8b0478c881ef99cf4">precondition</a> (std::vector&lt; R &gt; &amp;parameters, std::vector&lt; R &gt; &amp;action) const</td></tr>
<tr class="memdesc:a66a707d2bc8900f8b0478c881ef99cf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the Davidson preconditioner.  <a href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#a66a707d2bc8900f8b0478c881ef99cf4">More...</a><br /></td></tr>
<tr class="separator:a66a707d2bc8900f8b0478c881ef99cf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57e0b6fcfe3f0711b5c618f0660f2c3c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a4ce4d7778dab44edee1bea7075d7f227">scalar_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#a57e0b6fcfe3f0711b5c618f0660f2c3c">eigenvalues</a> () const override</td></tr>
<tr class="memdesc:a57e0b6fcfe3f0711b5c618f0660f2c3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The calculated eigenvalues of the subspace matrix.  <a href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#a57e0b6fcfe3f0711b5c618f0660f2c3c">More...</a><br /></td></tr>
<tr class="separator:a57e0b6fcfe3f0711b5c618f0660f2c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0cc61ce681e6c9f07a4a869d1caf33d"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a4ce4d7778dab44edee1bea7075d7f227">scalar_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#ad0cc61ce681e6c9f07a4a869d1caf33d">working_set_eigenvalues</a> () const override</td></tr>
<tr class="separator:ad0cc61ce681e6c9f07a4a869d1caf33d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8358829492685415686f92b83d7962fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#a8358829492685415686f92b83d7962fc">set_value_errors</a> () override</td></tr>
<tr class="memdesc:a8358829492685415686f92b83d7962fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation class should overload this to set errors in the current values (e.g. change in eigenvalues)  <a href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#a8358829492685415686f92b83d7962fc">More...</a><br /></td></tr>
<tr class="separator:a8358829492685415686f92b83d7962fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac264beb56a500ce1a90edd391ad16b87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#ac264beb56a500ce1a90edd391ad16b87">report</a> (std::ostream &amp;cout, bool endl=true) const override</td></tr>
<tr class="memdesc:ac264beb56a500ce1a90edd391ad16b87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a report to cout output stream.  <a href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#ac264beb56a500ce1a90edd391ad16b87">More...</a><br /></td></tr>
<tr class="separator:ac264beb56a500ce1a90edd391ad16b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4e8f66aaaa54da8eb41e2a5733ece1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#ab4e8f66aaaa54da8eb41e2a5733ece1d">set_reset_D</a> (size_t n)</td></tr>
<tr class="memdesc:ab4e8f66aaaa54da8eb41e2a5733ece1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the period in iterations for resetting the D space.  <a href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#ab4e8f66aaaa54da8eb41e2a5733ece1d">More...</a><br /></td></tr>
<tr class="separator:ab4e8f66aaaa54da8eb41e2a5733ece1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a925f70a6fb1a01ede8dd5a6dc0b7dedb"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#a925f70a6fb1a01ede8dd5a6dc0b7dedb">get_reset_D</a> () const</td></tr>
<tr class="separator:a925f70a6fb1a01ede8dd5a6dc0b7dedb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a241caed8a5b1e346fc978729892f6260"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#a241caed8a5b1e346fc978729892f6260">set_reset_D_maxQ_size</a> (size_t n)</td></tr>
<tr class="memdesc:a241caed8a5b1e346fc978729892f6260"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum size of Q space after resetting the D space.  <a href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#a241caed8a5b1e346fc978729892f6260">More...</a><br /></td></tr>
<tr class="separator:a241caed8a5b1e346fc978729892f6260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dabbe4326a656e6cb8f9a1018ceca3d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#a1dabbe4326a656e6cb8f9a1018ceca3d">get_reset_D_maxQ_size</a> () const</td></tr>
<tr class="separator:a1dabbe4326a656e6cb8f9a1018ceca3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a053621c2fdae8dcf9c4542ee97888ff7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#a053621c2fdae8dcf9c4542ee97888ff7">get_max_size_qspace</a> () const</td></tr>
<tr class="separator:a053621c2fdae8dcf9c4542ee97888ff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b363a8031dc1b31e0d70783428a5ab9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#a5b363a8031dc1b31e0d70783428a5ab9">set_max_size_qspace</a> (int n)</td></tr>
<tr class="separator:a5b363a8031dc1b31e0d70783428a5ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30cfe987c737da469e7a86a8725586a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#a30cfe987c737da469e7a86a8725586a4">set_hermiticity</a> (bool hermitian) override</td></tr>
<tr class="memdesc:a30cfe987c737da469e7a86a8725586a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets hermiticity of kernel.  <a href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#a30cfe987c737da469e7a86a8725586a4">More...</a><br /></td></tr>
<tr class="separator:a30cfe987c737da469e7a86a8725586a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a0109d914fa9d1c4f40fdc54b835efa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#a3a0109d914fa9d1c4f40fdc54b835efa">get_hermiticity</a> () const override</td></tr>
<tr class="memdesc:a3a0109d914fa9d1c4f40fdc54b835efa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets hermiticity of kernel, if true than it is hermitian, otherwise it is not.  <a href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#a3a0109d914fa9d1c4f40fdc54b835efa">More...</a><br /></td></tr>
<tr class="separator:a3a0109d914fa9d1c4f40fdc54b835efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa46edad2cecdac0a051062435a7188f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#aa46edad2cecdac0a051062435a7188f1">set_options</a> (const <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1Options.html">Options</a> &amp;<a class="el" href="namespacemolpro_1_1linalg.html#abd04a7feed3604605815d55678fc2369">options</a>) override</td></tr>
<tr class="separator:aa46edad2cecdac0a051062435a7188f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea95c0b3b85e393fac9d39c931463c03"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1Options.html">Options</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#aea95c0b3b85e393fac9d39c931463c03">get_options</a> () const override</td></tr>
<tr class="separator:aea95c0b3b85e393fac9d39c931463c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html">molpro::linalg::itsolv::IterativeSolverTemplate&lt; LinearEigensystem, R, R, std::map&lt; size_t, typename R::value_type &gt; &gt;</a></td></tr>
<tr class="memitem:acd19351fb4f3e8e98507cf0ec6b0032a inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#acd19351fb4f3e8e98507cf0ec6b0032a">IterativeSolverTemplate</a> ()=delete</td></tr>
<tr class="separator:acd19351fb4f3e8e98507cf0ec6b0032a inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac708b53560e38d7928e84868f6e1091 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#aac708b53560e38d7928e84868f6e1091">IterativeSolverTemplate</a> (const <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html">IterativeSolverTemplate</a>&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystem.html">LinearEigensystem</a>, R, R, std::map&lt; size_t, typename R::value_type &gt; &gt; &amp;)=delete</td></tr>
<tr class="separator:aac708b53560e38d7928e84868f6e1091 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc08e3ccc737019e8a77796deea4b417 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#afc08e3ccc737019e8a77796deea4b417">IterativeSolverTemplate</a> (<a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html">IterativeSolverTemplate</a>&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystem.html">LinearEigensystem</a>, R, R, std::map&lt; size_t, typename R::value_type &gt; &gt; &amp;&amp;) noexcept=default</td></tr>
<tr class="separator:afc08e3ccc737019e8a77796deea4b417 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f38f1278d9a9f6c3c170b188114ed8b inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html">IterativeSolverTemplate</a>&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystem.html">LinearEigensystem</a>, R, R, std::map&lt; size_t, typename R::value_type &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a6f38f1278d9a9f6c3c170b188114ed8b">operator=</a> (const <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html">IterativeSolverTemplate</a>&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystem.html">LinearEigensystem</a>, R, R, std::map&lt; size_t, typename R::value_type &gt; &gt; &amp;)=delete</td></tr>
<tr class="separator:a6f38f1278d9a9f6c3c170b188114ed8b inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a143dac00773f825e5f5221873a2ef351 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html">IterativeSolverTemplate</a>&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystem.html">LinearEigensystem</a>, R, R, std::map&lt; size_t, typename R::value_type &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a143dac00773f825e5f5221873a2ef351">operator=</a> (<a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html">IterativeSolverTemplate</a>&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystem.html">LinearEigensystem</a>, R, R, std::map&lt; size_t, typename R::value_type &gt; &gt; &amp;&amp;) noexcept=default</td></tr>
<tr class="separator:a143dac00773f825e5f5221873a2ef351 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5ed89e3da36e7f9e4b065213826e703 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#aa5ed89e3da36e7f9e4b065213826e703">add_vector</a> (const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ab44c7c7dfce88d39d260d1f5c7b70fab">VecRef</a>&lt; R &gt; &amp;parameters, const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ab44c7c7dfce88d39d260d1f5c7b70fab">VecRef</a>&lt; R &gt; &amp;actions) override</td></tr>
<tr class="separator:aa5ed89e3da36e7f9e4b065213826e703 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91aaa9e988aa4524bed5a639314b6b2c inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a91aaa9e988aa4524bed5a639314b6b2c">add_vector</a> (std::vector&lt; R &gt; &amp;parameters, std::vector&lt; R &gt; &amp;actions) override</td></tr>
<tr class="separator:a91aaa9e988aa4524bed5a639314b6b2c inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac96d822e308648c5e295389bcdd460ea inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#ac96d822e308648c5e295389bcdd460ea">add_vector</a> (R &amp;parameters, R &amp;actions, <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a027b41582a1fff9ebb679e6ae6e2fe5f">value_type</a> <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a2cfe4f0a54b136895de82f5a357e4cd4">value</a>=0) override</td></tr>
<tr class="separator:ac96d822e308648c5e295389bcdd460ea inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d1c168044d4511885f06f8aa50f618e inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a1d1c168044d4511885f06f8aa50f618e">add_p</a> (const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#aafd1821a97ea122d56be347e38e90a89">CVecRef</a>&lt; std::map&lt; size_t, typename R::value_type &gt; &gt; &amp;pparams, const <a class="el" href="classmolpro_1_1linalg_1_1array_1_1span_1_1Span.html">array::Span</a>&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a027b41582a1fff9ebb679e6ae6e2fe5f">value_type</a> &gt; &amp;pp_action_matrix, const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ab44c7c7dfce88d39d260d1f5c7b70fab">VecRef</a>&lt; R &gt; &amp;parameters, const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ab44c7c7dfce88d39d260d1f5c7b70fab">VecRef</a>&lt; R &gt; &amp;actions, <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a64287edfda9bc2abbdafd958b6cfe682">fapply_on_p_type</a> apply_p) override</td></tr>
<tr class="separator:a1d1c168044d4511885f06f8aa50f618e inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa72cab3838296b747e499d86682b3728 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#aa72cab3838296b747e499d86682b3728">clearP</a> () override</td></tr>
<tr class="separator:aa72cab3838296b747e499d86682b3728 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4e0f137f12bf9731d347f9dcc451b0b inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#af4e0f137f12bf9731d347f9dcc451b0b">solution</a> (const std::vector&lt; int &gt; &amp;roots, const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ab44c7c7dfce88d39d260d1f5c7b70fab">VecRef</a>&lt; R &gt; &amp;parameters, const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ab44c7c7dfce88d39d260d1f5c7b70fab">VecRef</a>&lt; R &gt; &amp;residual) override</td></tr>
<tr class="separator:af4e0f137f12bf9731d347f9dcc451b0b inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a493bdf1e89e15c55b9a82425864ca610 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a493bdf1e89e15c55b9a82425864ca610">solution</a> (const std::vector&lt; int &gt; &amp;roots, std::vector&lt; R &gt; &amp;parameters, std::vector&lt; R &gt; &amp;residual) override</td></tr>
<tr class="separator:a493bdf1e89e15c55b9a82425864ca610 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97c813a5516113c4fdc5dc9abd44fa87 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a97c813a5516113c4fdc5dc9abd44fa87">solution</a> (R &amp;parameters, R &amp;residual) override</td></tr>
<tr class="separator:a97c813a5516113c4fdc5dc9abd44fa87 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a238c04489ae2e21f9f188a80aacbae11 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a238c04489ae2e21f9f188a80aacbae11">solution_params</a> (const std::vector&lt; int &gt; &amp;roots, std::vector&lt; R &gt; &amp;parameters) override</td></tr>
<tr class="separator:a238c04489ae2e21f9f188a80aacbae11 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa292796dc4eed09b0131e887f0f5c174 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#aa292796dc4eed09b0131e887f0f5c174">solution_params</a> (const std::vector&lt; int &gt; &amp;roots, const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ab44c7c7dfce88d39d260d1f5c7b70fab">VecRef</a>&lt; R &gt; &amp;parameters) override</td></tr>
<tr class="separator:aa292796dc4eed09b0131e887f0f5c174 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92c5d693781ef363399bdc62832135f9 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a92c5d693781ef363399bdc62832135f9">solution_params</a> (R &amp;parameters) override</td></tr>
<tr class="separator:a92c5d693781ef363399bdc62832135f9 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba447f125747f4a70c8cabafc6c9143a inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#aba447f125747f4a70c8cabafc6c9143a">suggest_p</a> (const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#aafd1821a97ea122d56be347e38e90a89">CVecRef</a>&lt; R &gt; &amp;<a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#af4e0f137f12bf9731d347f9dcc451b0b">solution</a>, const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#aafd1821a97ea122d56be347e38e90a89">CVecRef</a>&lt; R &gt; &amp;residual, size_t max_number, double threshold) override</td></tr>
<tr class="separator:aba447f125747f4a70c8cabafc6c9143a inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeb52c0ee58811527f789e9675674cb0 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#abeb52c0ee58811527f789e9675674cb0">working_set</a> () const override</td></tr>
<tr class="separator:abeb52c0ee58811527f789e9675674cb0 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d328cf80c92a542338fcaf30f8e0606 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a6d328cf80c92a542338fcaf30f8e0606">n_roots</a> () const override</td></tr>
<tr class="separator:a6d328cf80c92a542338fcaf30f8e0606 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a326a2d0f672de203c54bbde4b7020368 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a326a2d0f672de203c54bbde4b7020368">set_n_roots</a> (size_t roots) override</td></tr>
<tr class="separator:a326a2d0f672de203c54bbde4b7020368 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3edaefda50129b65bd9b829a3d7d931 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#ac3edaefda50129b65bd9b829a3d7d931">set_options</a> (const <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1Options.html">Options</a> &amp;options) override</td></tr>
<tr class="separator:ac3edaefda50129b65bd9b829a3d7d931 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fc49ccc780ab47d600a06ab45064636 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1Options.html">Options</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a6fc49ccc780ab47d600a06ab45064636">get_options</a> () const override</td></tr>
<tr class="separator:a6fc49ccc780ab47d600a06ab45064636 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab105433d45a262ddf9adbd4cb36e9628 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a4ce4d7778dab44edee1bea7075d7f227">scalar_type</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#ab105433d45a262ddf9adbd4cb36e9628">errors</a> () const override</td></tr>
<tr class="separator:ab105433d45a262ddf9adbd4cb36e9628 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93bf7e1af72600b6293d3a072eedeaa6 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1Statistics.html">Statistics</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a93bf7e1af72600b6293d3a072eedeaa6">statistics</a> () const override</td></tr>
<tr class="separator:a93bf7e1af72600b6293d3a072eedeaa6 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2586061786c83f40ee932189f6a59353 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a2586061786c83f40ee932189f6a59353">report</a> (std::ostream &amp;cout, bool endl=true) const override</td></tr>
<tr class="separator:a2586061786c83f40ee932189f6a59353 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4748964a82d882be6cfebd7c158511e inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#ab4748964a82d882be6cfebd7c158511e">report</a> () const override</td></tr>
<tr class="separator:ab4748964a82d882be6cfebd7c158511e inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a215df7cdb4fd2d07f3c7f4acb7c58f34 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a215df7cdb4fd2d07f3c7f4acb7c58f34">set_convergence_threshold</a> (double thresh) override</td></tr>
<tr class="separator:a215df7cdb4fd2d07f3c7f4acb7c58f34 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d42e5e1955b041a57e421a4439d53c0 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a6d42e5e1955b041a57e421a4439d53c0">convergence_threshold</a> () const override</td></tr>
<tr class="separator:a6d42e5e1955b041a57e421a4439d53c0 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa13ca336fed0aea5f331e023f3d626b1 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#aa13ca336fed0aea5f331e023f3d626b1">set_convergence_threshold_value</a> (double thresh) override</td></tr>
<tr class="separator:aa13ca336fed0aea5f331e023f3d626b1 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76b475dca1b9e715b5aefd549acc48dc inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a76b475dca1b9e715b5aefd549acc48dc">convergence_threshold_value</a> () const override</td></tr>
<tr class="separator:a76b475dca1b9e715b5aefd549acc48dc inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6ffddd7ef42abcddf96847b6fe3e897 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#ad6ffddd7ef42abcddf96847b6fe3e897">set_verbosity</a> (<a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ac8246e59286ac3630c4c80231d6ed172">Verbosity</a> v) override</td></tr>
<tr class="separator:ad6ffddd7ef42abcddf96847b6fe3e897 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1240a8405dbaa9cda64e3d684bce2d5 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#af1240a8405dbaa9cda64e3d684bce2d5">set_verbosity</a> (int v) override</td></tr>
<tr class="separator:af1240a8405dbaa9cda64e3d684bce2d5 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af20d7396488162b24ab0565201132fc0 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ac8246e59286ac3630c4c80231d6ed172">Verbosity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#af20d7396488162b24ab0565201132fc0">get_verbosity</a> () const override</td></tr>
<tr class="separator:af20d7396488162b24ab0565201132fc0 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d206ec8158a042fa45b50eb417dd24d inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a4d206ec8158a042fa45b50eb417dd24d">set_max_iter</a> (int n) override</td></tr>
<tr class="separator:a4d206ec8158a042fa45b50eb417dd24d inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227f5b950f220fef378ee86ec7b9da92 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a227f5b950f220fef378ee86ec7b9da92">get_max_iter</a> () const override</td></tr>
<tr class="separator:a227f5b950f220fef378ee86ec7b9da92 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f1240d8cc340f434400894f5504e913 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a5f1240d8cc340f434400894f5504e913">set_max_p</a> (int n) override</td></tr>
<tr class="separator:a5f1240d8cc340f434400894f5504e913 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64f2b7857436d5df6cb76a1fa51f4135 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a64f2b7857436d5df6cb76a1fa51f4135">get_max_p</a> () const override</td></tr>
<tr class="separator:a64f2b7857436d5df6cb76a1fa51f4135 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f49c4695490cbd7107eddda0a5bc7b3 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a8f49c4695490cbd7107eddda0a5bc7b3">set_p_threshold</a> (double threshold) override</td></tr>
<tr class="separator:a8f49c4695490cbd7107eddda0a5bc7b3 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a261ed5e2536b16ce500022eac143b541 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a261ed5e2536b16ce500022eac143b541">get_p_threshold</a> () const override</td></tr>
<tr class="separator:a261ed5e2536b16ce500022eac143b541 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a83306888d70445233f01d4020d111a inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1subspace_1_1Dimensions.html">subspace::Dimensions</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a7a83306888d70445233f01d4020d111a">dimensions</a> () const override</td></tr>
<tr class="memdesc:a7a83306888d70445233f01d4020d111a inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access dimensions of the subspace.  <a href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a7a83306888d70445233f01d4020d111a">More...</a><br /></td></tr>
<tr class="separator:a7a83306888d70445233f01d4020d111a inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cfe4f0a54b136895de82f5a357e4cd4 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a4ce4d7778dab44edee1bea7075d7f227">scalar_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a2cfe4f0a54b136895de82f5a357e4cd4">value</a> () const override</td></tr>
<tr class="separator:a2cfe4f0a54b136895de82f5a357e4cd4 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17509a0c4ccbd30a313f3e606dc54696 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a17509a0c4ccbd30a313f3e606dc54696">set_profiler</a> (<a class="elRef" href="https://molpro.github.io/profiler/classmolpro_1_1profiler_1_1Profiler.html">molpro::profiler::Profiler</a> &amp;<a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a7b76f421dedacaaaac6d4da01b80e3cd">profiler</a>) override</td></tr>
<tr class="separator:a17509a0c4ccbd30a313f3e606dc54696 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b76f421dedacaaaac6d4da01b80e3cd inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">const std::shared_ptr&lt; <a class="elRef" href="https://molpro.github.io/profiler/classmolpro_1_1profiler_1_1Profiler.html">molpro::profiler::Profiler</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a7b76f421dedacaaaac6d4da01b80e3cd">profiler</a> () const override</td></tr>
<tr class="separator:a7b76f421dedacaaaac6d4da01b80e3cd inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad86a191289fae16f2d6df34f3b3ddad4 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#ad86a191289fae16f2d6df34f3b3ddad4">solve</a> (const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ab44c7c7dfce88d39d260d1f5c7b70fab">VecRef</a>&lt; R &gt; &amp;parameters, const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ab44c7c7dfce88d39d260d1f5c7b70fab">VecRef</a>&lt; R &gt; &amp;actions, const <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1Problem.html">Problem</a>&lt; R &gt; &amp;problem, bool generate_initial_guess=false) override</td></tr>
<tr class="separator:ad86a191289fae16f2d6df34f3b3ddad4 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa15c94f22aef32292f8c81bc4d5b4dc inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#aaa15c94f22aef32292f8c81bc4d5b4dc">solve</a> (R &amp;parameters, R &amp;actions, const <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1Problem.html">Problem</a>&lt; R &gt; &amp;problem, bool generate_initial_guess=false) override</td></tr>
<tr class="separator:aaa15c94f22aef32292f8c81bc4d5b4dc inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0f9db2eec5cb8d9153fe5ab23db017f inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#ac0f9db2eec5cb8d9153fe5ab23db017f">solve</a> (std::vector&lt; R &gt; &amp;parameters, std::vector&lt; R &gt; &amp;actions, const <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1Problem.html">Problem</a>&lt; R &gt; &amp;problem, bool generate_initial_guess=false) override</td></tr>
<tr class="separator:ac0f9db2eec5cb8d9153fe5ab23db017f inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d2794b425152880052b48e64116f295 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a5d2794b425152880052b48e64116f295">test_problem</a> (const <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1Problem.html">Problem</a>&lt; R &gt; &amp;problem, R &amp;v0, R &amp;v1, int verbosity, double threshold) const override</td></tr>
<tr class="separator:a5d2794b425152880052b48e64116f295 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c74967a8caabeeb48d4e5b9a12f42c8"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a4ce4d7778dab44edee1bea7075d7f227">scalar_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystem.html#a6c74967a8caabeeb48d4e5b9a12f42c8">eigenvalues</a> () const=0</td></tr>
<tr class="memdesc:a6c74967a8caabeeb48d4e5b9a12f42c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The calculated eigenvalues of the subspace matrix.  <a href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystem.html#a6c74967a8caabeeb48d4e5b9a12f42c8">More...</a><br /></td></tr>
<tr class="separator:a6c74967a8caabeeb48d4e5b9a12f42c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e43e2aa5f24212eb3562324554ce4f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystem.html#a66e43e2aa5f24212eb3562324554ce4f">set_hermiticity</a> (bool hermitian)=0</td></tr>
<tr class="memdesc:a66e43e2aa5f24212eb3562324554ce4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets hermiticity of kernel.  <a href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystem.html#a66e43e2aa5f24212eb3562324554ce4f">More...</a><br /></td></tr>
<tr class="separator:a66e43e2aa5f24212eb3562324554ce4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1280ef097d90b4b1f1ed608db76f1071"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystem.html#a1280ef097d90b4b1f1ed608db76f1071">get_hermiticity</a> () const=0</td></tr>
<tr class="memdesc:a1280ef097d90b4b1f1ed608db76f1071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets hermiticity of kernel, if true than it is hermitian, otherwise it is not.  <a href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystem.html#a1280ef097d90b4b1f1ed608db76f1071">More...</a><br /></td></tr>
<tr class="separator:a1280ef097d90b4b1f1ed608db76f1071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html">molpro::linalg::itsolv::IterativeSolver&lt; R, R, std::map&lt; size_t, typename R::value_type &gt; &gt;</a></td></tr>
<tr class="memitem:abc808a3db4d9f21e50b071fee35cb083 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#abc808a3db4d9f21e50b071fee35cb083">~IterativeSolver</a> ()=default</td></tr>
<tr class="separator:abc808a3db4d9f21e50b071fee35cb083 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e49705c8f5b805ff69f535ffcba5efc inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a7e49705c8f5b805ff69f535ffcba5efc">IterativeSolver</a> ()=default</td></tr>
<tr class="separator:a7e49705c8f5b805ff69f535ffcba5efc inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dab6f5601a84fa64d00e8e5628a3a1e inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a0dab6f5601a84fa64d00e8e5628a3a1e">IterativeSolver</a> (const <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html">IterativeSolver</a>&lt; R, R, std::map&lt; size_t, typename R::value_type &gt; &gt; &amp;)=delete</td></tr>
<tr class="separator:a0dab6f5601a84fa64d00e8e5628a3a1e inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3becd034ba0358533dda8362a1283a01 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a3becd034ba0358533dda8362a1283a01">IterativeSolver</a> (<a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html">IterativeSolver</a>&lt; R, R, std::map&lt; size_t, typename R::value_type &gt; &gt; &amp;&amp;) noexcept=default</td></tr>
<tr class="separator:a3becd034ba0358533dda8362a1283a01 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac79eab8cc43e2ee4a4f1cdff0fb53625 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html">IterativeSolver</a>&lt; R, R, std::map&lt; size_t, typename R::value_type &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#ac79eab8cc43e2ee4a4f1cdff0fb53625">operator=</a> (const <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html">IterativeSolver</a>&lt; R, R, std::map&lt; size_t, typename R::value_type &gt; &gt; &amp;)=delete</td></tr>
<tr class="separator:ac79eab8cc43e2ee4a4f1cdff0fb53625 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91e37bb38e22e0add6749afe16cc15c0 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html">IterativeSolver</a>&lt; R, R, std::map&lt; size_t, typename R::value_type &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a91e37bb38e22e0add6749afe16cc15c0">operator=</a> (<a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html">IterativeSolver</a>&lt; R, R, std::map&lt; size_t, typename R::value_type &gt; &gt; &amp;&amp;) noexcept=default</td></tr>
<tr class="separator:a91e37bb38e22e0add6749afe16cc15c0 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a527854d92a5f67f6bee487f46ea02524 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a527854d92a5f67f6bee487f46ea02524">solve</a> (const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ab44c7c7dfce88d39d260d1f5c7b70fab">VecRef</a>&lt; R &gt; &amp;parameters, const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ab44c7c7dfce88d39d260d1f5c7b70fab">VecRef</a>&lt; R &gt; &amp;actions, const <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1Problem.html">Problem</a>&lt; R &gt; &amp;problem, bool generate_initial_guess=false)=0</td></tr>
<tr class="memdesc:a527854d92a5f67f6bee487f46ea02524 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplified one-call solver.  <a href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a527854d92a5f67f6bee487f46ea02524">More...</a><br /></td></tr>
<tr class="separator:a527854d92a5f67f6bee487f46ea02524 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15457ee3cf4ffe270f869a3bedae6ef3 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a15457ee3cf4ffe270f869a3bedae6ef3">solve</a> (R &amp;parameters, R &amp;actions, const <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1Problem.html">Problem</a>&lt; R &gt; &amp;problem, bool generate_initial_guess=false)=0</td></tr>
<tr class="separator:a15457ee3cf4ffe270f869a3bedae6ef3 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac87a7c8e687fb61521e51daed48b1ba5 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#ac87a7c8e687fb61521e51daed48b1ba5">solve</a> (std::vector&lt; R &gt; &amp;parameters, std::vector&lt; R &gt; &amp;actions, const <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1Problem.html">Problem</a>&lt; R &gt; &amp;problem, bool generate_initial_guess=false)=0</td></tr>
<tr class="separator:ac87a7c8e687fb61521e51daed48b1ba5 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76529da2bee144bb54981e0350702554 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a76529da2bee144bb54981e0350702554">add_vector</a> (const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ab44c7c7dfce88d39d260d1f5c7b70fab">VecRef</a>&lt; R &gt; &amp;parameters, const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ab44c7c7dfce88d39d260d1f5c7b70fab">VecRef</a>&lt; R &gt; &amp;actions)=0</td></tr>
<tr class="memdesc:a76529da2bee144bb54981e0350702554 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take, typically, a current solution and residual, and add it to the solution space.  <a href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a76529da2bee144bb54981e0350702554">More...</a><br /></td></tr>
<tr class="separator:a76529da2bee144bb54981e0350702554 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a83c4f944907a2a74f115d99062a073 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a9a83c4f944907a2a74f115d99062a073">add_vector</a> (std::vector&lt; R &gt; &amp;parameters, std::vector&lt; R &gt; &amp;action)=0</td></tr>
<tr class="separator:a9a83c4f944907a2a74f115d99062a073 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a35595f2fb582a71f2b9fbe7164af4a inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a2a35595f2fb582a71f2b9fbe7164af4a">add_vector</a> (R &amp;parameters, R &amp;action, <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a027b41582a1fff9ebb679e6ae6e2fe5f">value_type</a> <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a1a1d0c58c9e41e405bfa1cfff8179e1e">value</a>=0)=0</td></tr>
<tr class="separator:a2a35595f2fb582a71f2b9fbe7164af4a inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f2cb71b3bc51e8163c0658113fb2929 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a9f2cb71b3bc51e8163c0658113fb2929">add_p</a> (const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#aafd1821a97ea122d56be347e38e90a89">CVecRef</a>&lt; std::map&lt; size_t, typename R::value_type &gt; &gt; &amp;pparams, const <a class="el" href="classmolpro_1_1linalg_1_1array_1_1span_1_1Span.html">array::Span</a>&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a027b41582a1fff9ebb679e6ae6e2fe5f">value_type</a> &gt; &amp;pp_action_matrix, const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ab44c7c7dfce88d39d260d1f5c7b70fab">VecRef</a>&lt; R &gt; &amp;parameters, const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ab44c7c7dfce88d39d260d1f5c7b70fab">VecRef</a>&lt; R &gt; &amp;action, <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a64287edfda9bc2abbdafd958b6cfe682">fapply_on_p_type</a> apply_p)=0</td></tr>
<tr class="memdesc:a9f2cb71b3bc51e8163c0658113fb2929 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add P-space vectors to the expansion set for linear methods.  <a href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a9f2cb71b3bc51e8163c0658113fb2929">More...</a><br /></td></tr>
<tr class="separator:a9f2cb71b3bc51e8163c0658113fb2929 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2720fd380825d896d248c1a45a2f5b01 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a2720fd380825d896d248c1a45a2f5b01">clearP</a> ()=0</td></tr>
<tr class="separator:a2720fd380825d896d248c1a45a2f5b01 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a520b858fe56b45bf13090a62854f2586 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a520b858fe56b45bf13090a62854f2586">solution</a> (const std::vector&lt; int &gt; &amp;roots, const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ab44c7c7dfce88d39d260d1f5c7b70fab">VecRef</a>&lt; R &gt; &amp;parameters, const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ab44c7c7dfce88d39d260d1f5c7b70fab">VecRef</a>&lt; R &gt; &amp;residual)=0</td></tr>
<tr class="memdesc:a520b858fe56b45bf13090a62854f2586 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct solution and residual for a given set of roots.  <a href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a520b858fe56b45bf13090a62854f2586">More...</a><br /></td></tr>
<tr class="separator:a520b858fe56b45bf13090a62854f2586 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0abcaa62ea4fb7c66061e6cae6d4247 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#aa0abcaa62ea4fb7c66061e6cae6d4247">solution</a> (const std::vector&lt; int &gt; &amp;roots, std::vector&lt; R &gt; &amp;parameters, std::vector&lt; R &gt; &amp;residual)=0</td></tr>
<tr class="separator:aa0abcaa62ea4fb7c66061e6cae6d4247 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8fabc3bee2f9d6d589e239f8d0aedbf inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#aa8fabc3bee2f9d6d589e239f8d0aedbf">solution</a> (R &amp;parameters, R &amp;residual)=0</td></tr>
<tr class="separator:aa8fabc3bee2f9d6d589e239f8d0aedbf inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a597a254411508028bc9638b59ab9b639 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a597a254411508028bc9638b59ab9b639">solution_params</a> (const std::vector&lt; int &gt; &amp;roots, const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ab44c7c7dfce88d39d260d1f5c7b70fab">VecRef</a>&lt; R &gt; &amp;parameters)=0</td></tr>
<tr class="memdesc:a597a254411508028bc9638b59ab9b639 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs parameters of selected roots.  <a href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a597a254411508028bc9638b59ab9b639">More...</a><br /></td></tr>
<tr class="separator:a597a254411508028bc9638b59ab9b639 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0725b38684c71dc582fa03220b5b685 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#ae0725b38684c71dc582fa03220b5b685">solution_params</a> (const std::vector&lt; int &gt; &amp;roots, std::vector&lt; R &gt; &amp;parameters)=0</td></tr>
<tr class="separator:ae0725b38684c71dc582fa03220b5b685 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8262a59edc2354bb3e8055cfc4fbd8cd inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a8262a59edc2354bb3e8055cfc4fbd8cd">solution_params</a> (R &amp;parameters)=0</td></tr>
<tr class="separator:a8262a59edc2354bb3e8055cfc4fbd8cd inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfce319e750a3e3a925c489b91dbf7e2 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#acfce319e750a3e3a925c489b91dbf7e2">end_iteration</a> (const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ab44c7c7dfce88d39d260d1f5c7b70fab">VecRef</a>&lt; R &gt; &amp;parameters, const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ab44c7c7dfce88d39d260d1f5c7b70fab">VecRef</a>&lt; R &gt; &amp;residual)=0</td></tr>
<tr class="memdesc:acfce319e750a3e3a925c489b91dbf7e2 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Behaviour depends on the solver.  <a href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#acfce319e750a3e3a925c489b91dbf7e2">More...</a><br /></td></tr>
<tr class="separator:acfce319e750a3e3a925c489b91dbf7e2 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af866452579638ebfa72eb5aa4e79cb97 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#af866452579638ebfa72eb5aa4e79cb97">end_iteration</a> (std::vector&lt; R &gt; &amp;parameters, std::vector&lt; R &gt; &amp;action)=0</td></tr>
<tr class="separator:af866452579638ebfa72eb5aa4e79cb97 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e6b71a13a52437b18b22ace59fcc489 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a1e6b71a13a52437b18b22ace59fcc489">end_iteration</a> (R &amp;parameters, R &amp;action)=0</td></tr>
<tr class="separator:a1e6b71a13a52437b18b22ace59fcc489 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa96ff75d67276bc116c0c13eeb2de29 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#afa96ff75d67276bc116c0c13eeb2de29">suggest_p</a> (const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#aafd1821a97ea122d56be347e38e90a89">CVecRef</a>&lt; R &gt; &amp;<a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a520b858fe56b45bf13090a62854f2586">solution</a>, const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#aafd1821a97ea122d56be347e38e90a89">CVecRef</a>&lt; R &gt; &amp;residual, size_t max_number, double threshold)=0</td></tr>
<tr class="memdesc:afa96ff75d67276bc116c0c13eeb2de29 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the solver's suggestion of which degrees of freedom would be best to add to the P-space.  <a href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#afa96ff75d67276bc116c0c13eeb2de29">More...</a><br /></td></tr>
<tr class="separator:afa96ff75d67276bc116c0c13eeb2de29 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afee9d49b3360468c417d31259c740b1b inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memItemLeft" align="right" valign="top">virtual const std::vector&lt; int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#afee9d49b3360468c417d31259c740b1b">working_set</a> () const=0</td></tr>
<tr class="memdesc:afee9d49b3360468c417d31259c740b1b inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Working set of roots that are not yet converged.  <a href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#afee9d49b3360468c417d31259c740b1b">More...</a><br /></td></tr>
<tr class="separator:afee9d49b3360468c417d31259c740b1b inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acab3c3acb752c4c5d093cfe92923eda6 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a4ce4d7778dab44edee1bea7075d7f227">scalar_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#acab3c3acb752c4c5d093cfe92923eda6">working_set_eigenvalues</a> () const</td></tr>
<tr class="separator:acab3c3acb752c4c5d093cfe92923eda6 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdeae214ff9e4a8433409a8cd87b54e8 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#afdeae214ff9e4a8433409a8cd87b54e8">n_roots</a> () const=0</td></tr>
<tr class="separator:afdeae214ff9e4a8433409a8cd87b54e8 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53c71a0d711b5ca06bf7c7858532485d inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a53c71a0d711b5ca06bf7c7858532485d">set_n_roots</a> (size_t nroots)=0</td></tr>
<tr class="separator:a53c71a0d711b5ca06bf7c7858532485d inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7a498d8483214bb9fbbdaabcb469332 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memItemLeft" align="right" valign="top">virtual const std::vector&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a4ce4d7778dab44edee1bea7075d7f227">scalar_type</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#af7a498d8483214bb9fbbdaabcb469332">errors</a> () const=0</td></tr>
<tr class="separator:af7a498d8483214bb9fbbdaabcb469332 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3f63de0aab95e5c15d1d09f034c664d inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1Statistics.html">Statistics</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#af3f63de0aab95e5c15d1d09f034c664d">statistics</a> () const=0</td></tr>
<tr class="separator:af3f63de0aab95e5c15d1d09f034c664d inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a328990c674d38121f8ebbd5b51a26af0 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a328990c674d38121f8ebbd5b51a26af0">report</a> (std::ostream &amp;cout, bool endl=true) const=0</td></tr>
<tr class="memdesc:a328990c674d38121f8ebbd5b51a26af0 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a report to cout output stream.  <a href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a328990c674d38121f8ebbd5b51a26af0">More...</a><br /></td></tr>
<tr class="separator:a328990c674d38121f8ebbd5b51a26af0 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a4cbea70759f428d0934481642532b0 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a0a4cbea70759f428d0934481642532b0">report</a> () const=0</td></tr>
<tr class="memdesc:a0a4cbea70759f428d0934481642532b0 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a report to std::cout.  <a href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a0a4cbea70759f428d0934481642532b0">More...</a><br /></td></tr>
<tr class="separator:a0a4cbea70759f428d0934481642532b0 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af28ce838454c794908965639d9425b75 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#af28ce838454c794908965639d9425b75">set_convergence_threshold</a> (double thresh)=0</td></tr>
<tr class="memdesc:af28ce838454c794908965639d9425b75 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the convergence threshold.  <a href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#af28ce838454c794908965639d9425b75">More...</a><br /></td></tr>
<tr class="separator:af28ce838454c794908965639d9425b75 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae54969171361e0982c8336dbf087dc4 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#aae54969171361e0982c8336dbf087dc4">convergence_threshold</a> () const=0</td></tr>
<tr class="memdesc:aae54969171361e0982c8336dbf087dc4 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the convergence threshold.  <a href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#aae54969171361e0982c8336dbf087dc4">More...</a><br /></td></tr>
<tr class="separator:aae54969171361e0982c8336dbf087dc4 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5674166e14c2db01d9c9dcac437831f inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#ae5674166e14c2db01d9c9dcac437831f">set_convergence_threshold_value</a> (double thresh)=0</td></tr>
<tr class="memdesc:ae5674166e14c2db01d9c9dcac437831f inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value convergence threshold.  <a href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#ae5674166e14c2db01d9c9dcac437831f">More...</a><br /></td></tr>
<tr class="separator:ae5674166e14c2db01d9c9dcac437831f inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35298af04d9f0436ba2d41fd16d62cd2 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a35298af04d9f0436ba2d41fd16d62cd2">convergence_threshold_value</a> () const=0</td></tr>
<tr class="memdesc:a35298af04d9f0436ba2d41fd16d62cd2 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the value convergence threshold.  <a href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a35298af04d9f0436ba2d41fd16d62cd2">More...</a><br /></td></tr>
<tr class="separator:a35298af04d9f0436ba2d41fd16d62cd2 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21beaa60fd363e453ee9fae8e62b0823 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a21beaa60fd363e453ee9fae8e62b0823">set_verbosity</a> (<a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ac8246e59286ac3630c4c80231d6ed172">Verbosity</a> v)=0</td></tr>
<tr class="separator:a21beaa60fd363e453ee9fae8e62b0823 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a069c10af4c2e24f5b689747042c1a9fd inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a069c10af4c2e24f5b689747042c1a9fd">set_verbosity</a> (int v)=0</td></tr>
<tr class="separator:a069c10af4c2e24f5b689747042c1a9fd inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf07c86f31393212706518abe4a231cc inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ac8246e59286ac3630c4c80231d6ed172">Verbosity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#aaf07c86f31393212706518abe4a231cc">get_verbosity</a> () const=0</td></tr>
<tr class="separator:aaf07c86f31393212706518abe4a231cc inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d505916315180ef208ab2c2f68bf04d inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a9d505916315180ef208ab2c2f68bf04d">set_max_iter</a> (int n)=0</td></tr>
<tr class="separator:a9d505916315180ef208ab2c2f68bf04d inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae39e8d02193ed8d5690723433f5be0b8 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#ae39e8d02193ed8d5690723433f5be0b8">get_max_iter</a> () const=0</td></tr>
<tr class="separator:ae39e8d02193ed8d5690723433f5be0b8 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bd08099658ce5548af1fb1670c7cbfc inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a6bd08099658ce5548af1fb1670c7cbfc">set_max_p</a> (int n)=0</td></tr>
<tr class="separator:a6bd08099658ce5548af1fb1670c7cbfc inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde8118f66c77abc9df316bc63cf0355 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#adde8118f66c77abc9df316bc63cf0355">get_max_p</a> () const=0</td></tr>
<tr class="separator:adde8118f66c77abc9df316bc63cf0355 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a08eb4824d0037887dd95167249088 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a42a08eb4824d0037887dd95167249088">set_p_threshold</a> (double thresh)=0</td></tr>
<tr class="separator:a42a08eb4824d0037887dd95167249088 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36c67d3ad35534b41b49fc7bf931ebd3 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a36c67d3ad35534b41b49fc7bf931ebd3">get_p_threshold</a> () const=0</td></tr>
<tr class="separator:a36c67d3ad35534b41b49fc7bf931ebd3 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52bd10f0e2bb7d0f62a05fd0957d8c93 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1subspace_1_1Dimensions.html">subspace::Dimensions</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a52bd10f0e2bb7d0f62a05fd0957d8c93">dimensions</a> () const=0</td></tr>
<tr class="separator:a52bd10f0e2bb7d0f62a05fd0957d8c93 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e4e385f3faccb93d44a0e1b070bfa74 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a7e4e385f3faccb93d44a0e1b070bfa74">set_options</a> (const <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1Options.html">Options</a> &amp;options)=0</td></tr>
<tr class="separator:a7e4e385f3faccb93d44a0e1b070bfa74 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad22826350864db069a44a3a6aa1d15ea inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1Options.html">Options</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#ad22826350864db069a44a3a6aa1d15ea">get_options</a> () const=0</td></tr>
<tr class="separator:ad22826350864db069a44a3a6aa1d15ea inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a1d0c58c9e41e405bfa1cfff8179e1e inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a4ce4d7778dab44edee1bea7075d7f227">scalar_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a1a1d0c58c9e41e405bfa1cfff8179e1e">value</a> () const=0</td></tr>
<tr class="memdesc:a1a1d0c58c9e41e405bfa1cfff8179e1e inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report the function value for the current optimum solution.  <a href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a1a1d0c58c9e41e405bfa1cfff8179e1e">More...</a><br /></td></tr>
<tr class="separator:a1a1d0c58c9e41e405bfa1cfff8179e1e inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66ac1625fde41f28ade6cc29f81da931 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a66ac1625fde41f28ade6cc29f81da931">nonlinear</a> () const=0</td></tr>
<tr class="memdesc:a66ac1625fde41f28ade6cc29f81da931 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report whether the class is a non-linear solver.  <a href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a66ac1625fde41f28ade6cc29f81da931">More...</a><br /></td></tr>
<tr class="separator:a66ac1625fde41f28ade6cc29f81da931 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05a40f7a9c104db49a1057896f3cc457 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a05a40f7a9c104db49a1057896f3cc457">set_profiler</a> (<a class="elRef" href="https://molpro.github.io/profiler/classmolpro_1_1profiler_1_1Profiler.html">molpro::profiler::Profiler</a> &amp;<a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a9378ef23b2490ab5b69a05205c6f57ad">profiler</a>)=0</td></tr>
<tr class="memdesc:a05a40f7a9c104db49a1057896f3cc457 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach a profiler in order to collect performance data.  <a href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a05a40f7a9c104db49a1057896f3cc457">More...</a><br /></td></tr>
<tr class="separator:a05a40f7a9c104db49a1057896f3cc457 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9378ef23b2490ab5b69a05205c6f57ad inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memItemLeft" align="right" valign="top">virtual const std::shared_ptr&lt; <a class="elRef" href="https://molpro.github.io/profiler/classmolpro_1_1profiler_1_1Profiler.html">molpro::profiler::Profiler</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a9378ef23b2490ab5b69a05205c6f57ad">profiler</a> () const=0</td></tr>
<tr class="separator:a9378ef23b2490ab5b69a05205c6f57ad inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25e573d21d3d8eea3aa66f5cb8606aff inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a25e573d21d3d8eea3aa66f5cb8606aff">test_problem</a> (const <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1Problem.html">Problem</a>&lt; R &gt; &amp;problem, R &amp;v0, R &amp;v1, int verbosity=0, double threshold=1e-5) const=0</td></tr>
<tr class="memdesc:a25e573d21d3d8eea3aa66f5cb8606aff inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test a supplied problem class.  <a href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a25e573d21d3d8eea3aa66f5cb8606aff">More...</a><br /></td></tr>
<tr class="separator:a25e573d21d3d8eea3aa66f5cb8606aff inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a3928db7987c24bda78d24e2f18e6c1d5"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1Logger.html">Logger</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#a3928db7987c24bda78d24e2f18e6c1d5">logger</a></td></tr>
<tr class="separator:a3928db7987c24bda78d24e2f18e6c1d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc0bdc92047dafddad208549048eef54"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#abc0bdc92047dafddad208549048eef54">propose_rspace_norm_thresh</a> = 1e-10</td></tr>
<tr class="memdesc:abc0bdc92047dafddad208549048eef54"><td class="mdescLeft">&#160;</td><td class="mdescRight">vectors with norm less than threshold can be considered null.  <a href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#abc0bdc92047dafddad208549048eef54">More...</a><br /></td></tr>
<tr class="separator:abc0bdc92047dafddad208549048eef54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b96209972872ffece08f78a2c747c5a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#a3b96209972872ffece08f78a2c747c5a">propose_rspace_svd_thresh</a> = 1e-12</td></tr>
<tr class="separator:a3b96209972872ffece08f78a2c747c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:accbb21b9dc3c611e7bddd25d0750f972"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#accbb21b9dc3c611e7bddd25d0750f972">construct_residual</a> (const std::vector&lt; int &gt; &amp;roots, const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#aafd1821a97ea122d56be347e38e90a89">CVecRef</a>&lt; R &gt; &amp;params, const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ab44c7c7dfce88d39d260d1f5c7b70fab">VecRef</a>&lt; R &gt; &amp;actions) override</td></tr>
<tr class="memdesc:accbb21b9dc3c611e7bddd25d0750f972"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs residual for given roots provided their parameters and actions.  <a href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#accbb21b9dc3c611e7bddd25d0750f972">More...</a><br /></td></tr>
<tr class="separator:accbb21b9dc3c611e7bddd25d0750f972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html">molpro::linalg::itsolv::IterativeSolverTemplate&lt; LinearEigensystem, R, R, std::map&lt; size_t, typename R::value_type &gt; &gt;</a></td></tr>
<tr class="memitem:a8ae64ca06a5a8ddf6099eead01f66c23 inherit pro_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a8ae64ca06a5a8ddf6099eead01f66c23">IterativeSolverTemplate</a> (std::shared_ptr&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1subspace_1_1IXSpace.html">subspace::IXSpace</a>&lt; R, R, std::map&lt; size_t, typename R::value_type &gt; &gt; &gt; xspace, std::shared_ptr&lt; <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1subspace_1_1ISubspaceSolver.html">subspace::ISubspaceSolver</a>&lt; R, R, std::map&lt; size_t, typename R::value_type &gt; &gt; &gt; solver, std::shared_ptr&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1ArrayHandlers.html">ArrayHandlers</a>&lt; R, R, std::map&lt; size_t, typename R::value_type &gt; &gt; &gt; handlers, std::shared_ptr&lt; <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1Statistics.html">Statistics</a> &gt; stats, std::shared_ptr&lt; <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1Logger.html">Logger</a> &gt; logger)</td></tr>
<tr class="separator:a8ae64ca06a5a8ddf6099eead01f66c23 inherit pro_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da70aeae03caac6b144251c0d402d4c inherit pro_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a8da70aeae03caac6b144251c0d402d4c">~IterativeSolverTemplate</a> ()</td></tr>
<tr class="separator:a8da70aeae03caac6b144251c0d402d4c inherit pro_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf9774c4ebf5d2ac8f670236d417ceb6 inherit pro_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#abf9774c4ebf5d2ac8f670236d417ceb6">set_value_errors</a> ()</td></tr>
<tr class="memdesc:abf9774c4ebf5d2ac8f670236d417ceb6 inherit pro_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation class should overload this to set errors in the current values (e.g. change in eigenvalues)  <a href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#abf9774c4ebf5d2ac8f670236d417ceb6">More...</a><br /></td></tr>
<tr class="separator:abf9774c4ebf5d2ac8f670236d417ceb6 inherit pro_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac38e5b3cb441edb495c6084a72dbdac0 inherit pro_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#ac38e5b3cb441edb495c6084a72dbdac0">construct_residual</a> (const std::vector&lt; int &gt; &amp;roots, const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#aafd1821a97ea122d56be347e38e90a89">CVecRef</a>&lt; R &gt; &amp;params, const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ab44c7c7dfce88d39d260d1f5c7b70fab">VecRef</a>&lt; R &gt; &amp;actions)=0</td></tr>
<tr class="memdesc:ac38e5b3cb441edb495c6084a72dbdac0 inherit pro_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs residual for given roots provided their parameters and actions.  <a href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#ac38e5b3cb441edb495c6084a72dbdac0">More...</a><br /></td></tr>
<tr class="separator:ac38e5b3cb441edb495c6084a72dbdac0 inherit pro_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e68e1074cbc61076df22c6dc8d787a inherit pro_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a92e68e1074cbc61076df22c6dc8d787a">linearEigensystem</a> () const</td></tr>
<tr class="separator:a92e68e1074cbc61076df22c6dc8d787a inherit pro_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b1a5bfc4fb3d6876ab8535be73e69ce inherit pro_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a7b1a5bfc4fb3d6876ab8535be73e69ce">solve_and_generate_working_set</a> (const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ab44c7c7dfce88d39d260d1f5c7b70fab">VecRef</a>&lt; R &gt; &amp;parameters, const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ab44c7c7dfce88d39d260d1f5c7b70fab">VecRef</a>&lt; R &gt; &amp;action)</td></tr>
<tr class="memdesc:a7b1a5bfc4fb3d6876ab8535be73e69ce inherit pro_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves the subspace problems and selects the working set of roots, returning their parameters and residual in parameters and action.  <a href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a7b1a5bfc4fb3d6876ab8535be73e69ce">More...</a><br /></td></tr>
<tr class="separator:a7b1a5bfc4fb3d6876ab8535be73e69ce inherit pro_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54c5badcc785eede77893bfe2c8c8cb9 inherit pro_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a54c5badcc785eede77893bfe2c8c8cb9">check_consistent_number_of_roots_and_solutions</a> (const std::vector&lt; TTT &gt; &amp;roots, const size_t nparams)</td></tr>
<tr class="separator:a54c5badcc785eede77893bfe2c8c8cb9 inherit pro_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a482db55c4914b82cedcbbb3190c519f8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#a482db55c4914b82cedcbbb3190c519f8">m_max_size_qspace</a> = std::numeric_limits&lt;int&gt;::max()</td></tr>
<tr class="memdesc:a482db55c4914b82cedcbbb3190c519f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximum size of Q space  <a href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#a482db55c4914b82cedcbbb3190c519f8">More...</a><br /></td></tr>
<tr class="separator:a482db55c4914b82cedcbbb3190c519f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54f58e57011e81a3649959d5bf900b59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1detail_1_1DSpaceResetter.html">detail::DSpaceResetter</a>&lt; Q &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#a54f58e57011e81a3649959d5bf900b59">m_dspace_resetter</a></td></tr>
<tr class="memdesc:a54f58e57011e81a3649959d5bf900b59"><td class="mdescLeft">&#160;</td><td class="mdescRight">resets D space  <a href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#a54f58e57011e81a3649959d5bf900b59">More...</a><br /></td></tr>
<tr class="separator:a54f58e57011e81a3649959d5bf900b59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bf051b5bc298da49a9046af0feb0104"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#a9bf051b5bc298da49a9046af0feb0104">m_hermiticity</a> = false</td></tr>
<tr class="memdesc:a9bf051b5bc298da49a9046af0feb0104"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether the problem is hermitian or not  <a href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#a9bf051b5bc298da49a9046af0feb0104">More...</a><br /></td></tr>
<tr class="separator:a9bf051b5bc298da49a9046af0feb0104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f7dd1a80e4fdda081a2353d3cabb9e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#a26f7dd1a80e4fdda081a2353d3cabb9e">m_last_values</a></td></tr>
<tr class="memdesc:a26f7dd1a80e4fdda081a2353d3cabb9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The values from the previous iteration.  <a href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#a26f7dd1a80e4fdda081a2353d3cabb9e">More...</a><br /></td></tr>
<tr class="separator:a26f7dd1a80e4fdda081a2353d3cabb9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f8b13cbdbd2dc723312d0d640c31917"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#a4f8b13cbdbd2dc723312d0d640c31917">m_resetting_in_progress</a> = false</td></tr>
<tr class="memdesc:a4f8b13cbdbd2dc723312d0d640c31917"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether D space resetting is in progress  <a href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#a4f8b13cbdbd2dc723312d0d640c31917">More...</a><br /></td></tr>
<tr class="separator:a4f8b13cbdbd2dc723312d0d640c31917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html">molpro::linalg::itsolv::IterativeSolverTemplate&lt; LinearEigensystem, R, R, std::map&lt; size_t, typename R::value_type &gt; &gt;</a></td></tr>
<tr class="memitem:a3a9fde47c295d0370ba3d65b91bc9b95 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1ArrayHandlers.html">ArrayHandlers</a>&lt; R, R, std::map&lt; size_t, typename R::value_type &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a3a9fde47c295d0370ba3d65b91bc9b95">m_handlers</a></td></tr>
<tr class="memdesc:a3a9fde47c295d0370ba3d65b91bc9b95 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array handlers.  <a href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a3a9fde47c295d0370ba3d65b91bc9b95">More...</a><br /></td></tr>
<tr class="separator:a3a9fde47c295d0370ba3d65b91bc9b95 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dc73bdfa7e204116edab2d44b69e7cd inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1subspace_1_1IXSpace.html">subspace::IXSpace</a>&lt; R, R, std::map&lt; size_t, typename R::value_type &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a2dc73bdfa7e204116edab2d44b69e7cd">m_xspace</a></td></tr>
<tr class="memdesc:a2dc73bdfa7e204116edab2d44b69e7cd inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="mdescLeft">&#160;</td><td class="mdescRight">manages the subspace and associated data  <a href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a2dc73bdfa7e204116edab2d44b69e7cd">More...</a><br /></td></tr>
<tr class="separator:a2dc73bdfa7e204116edab2d44b69e7cd inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61e18e30ed35370994bb53003a5d4642 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1subspace_1_1ISubspaceSolver.html">subspace::ISubspaceSolver</a>&lt; R, R, std::map&lt; size_t, typename R::value_type &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a61e18e30ed35370994bb53003a5d4642">m_subspace_solver</a></td></tr>
<tr class="memdesc:a61e18e30ed35370994bb53003a5d4642 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="mdescLeft">&#160;</td><td class="mdescRight">solves the subspace problem  <a href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a61e18e30ed35370994bb53003a5d4642">More...</a><br /></td></tr>
<tr class="separator:a61e18e30ed35370994bb53003a5d4642 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac50fb7b6de5f3cfa26e703337060a0da inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#ac50fb7b6de5f3cfa26e703337060a0da">m_errors</a></td></tr>
<tr class="memdesc:ac50fb7b6de5f3cfa26e703337060a0da inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="mdescLeft">&#160;</td><td class="mdescRight">errors from the most recent solution  <a href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#ac50fb7b6de5f3cfa26e703337060a0da">More...</a><br /></td></tr>
<tr class="separator:ac50fb7b6de5f3cfa26e703337060a0da inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af75da06fcb4b67cbed43a74142eebb56 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#af75da06fcb4b67cbed43a74142eebb56">m_value_errors</a></td></tr>
<tr class="memdesc:af75da06fcb4b67cbed43a74142eebb56 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="mdescLeft">&#160;</td><td class="mdescRight">value errors from the most recent solution  <a href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#af75da06fcb4b67cbed43a74142eebb56">More...</a><br /></td></tr>
<tr class="separator:af75da06fcb4b67cbed43a74142eebb56 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a289ff256b61bc1746f7dd0fddd0b8166 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a289ff256b61bc1746f7dd0fddd0b8166">m_working_set</a></td></tr>
<tr class="memdesc:a289ff256b61bc1746f7dd0fddd0b8166 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="mdescLeft">&#160;</td><td class="mdescRight">indices of roots in the working set  <a href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a289ff256b61bc1746f7dd0fddd0b8166">More...</a><br /></td></tr>
<tr class="separator:a289ff256b61bc1746f7dd0fddd0b8166 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b5c7aee955bf41e7ad1d7a1889ce6e0 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a9b5c7aee955bf41e7ad1d7a1889ce6e0">m_nroots</a></td></tr>
<tr class="memdesc:a9b5c7aee955bf41e7ad1d7a1889ce6e0 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of roots the solver is searching for  <a href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a9b5c7aee955bf41e7ad1d7a1889ce6e0">More...</a><br /></td></tr>
<tr class="separator:a9b5c7aee955bf41e7ad1d7a1889ce6e0 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab88aa2f7710140556b2e670a54730784 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#ab88aa2f7710140556b2e670a54730784">m_convergence_threshold</a></td></tr>
<tr class="memdesc:ab88aa2f7710140556b2e670a54730784 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="mdescLeft">&#160;</td><td class="mdescRight">residual norms less than this mark a converged solution  <a href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#ab88aa2f7710140556b2e670a54730784">More...</a><br /></td></tr>
<tr class="separator:ab88aa2f7710140556b2e670a54730784 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae91c0ec6524d77c5a789f61995a01c43 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#ae91c0ec6524d77c5a789f61995a01c43">m_convergence_threshold_value</a></td></tr>
<tr class="memdesc:ae91c0ec6524d77c5a789f61995a01c43 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="mdescLeft">&#160;</td><td class="mdescRight">value changes less than this mark a converged solution  <a href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#ae91c0ec6524d77c5a789f61995a01c43">More...</a><br /></td></tr>
<tr class="separator:ae91c0ec6524d77c5a789f61995a01c43 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae24be2854a659d0b3c5a3fe8db922e5e inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1Statistics.html">Statistics</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#ae24be2854a659d0b3c5a3fe8db922e5e">m_stats</a></td></tr>
<tr class="memdesc:ae24be2854a659d0b3c5a3fe8db922e5e inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="mdescLeft">&#160;</td><td class="mdescRight">accumulates statistics of operations performed by the solver  <a href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#ae24be2854a659d0b3c5a3fe8db922e5e">More...</a><br /></td></tr>
<tr class="separator:ae24be2854a659d0b3c5a3fe8db922e5e inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abee358ce5516717e73670d75f2eebc45 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1Logger.html">Logger</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#abee358ce5516717e73670d75f2eebc45">m_logger</a></td></tr>
<tr class="memdesc:abee358ce5516717e73670d75f2eebc45 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="mdescLeft">&#160;</td><td class="mdescRight">logger  <a href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#abee358ce5516717e73670d75f2eebc45">More...</a><br /></td></tr>
<tr class="separator:abee358ce5516717e73670d75f2eebc45 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab53e871487e088b6502f51f6ec2ccab3 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#ab53e871487e088b6502f51f6ec2ccab3">m_normalise_solution</a></td></tr>
<tr class="memdesc:ab53e871487e088b6502f51f6ec2ccab3 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether to normalise the solutions  <a href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#ab53e871487e088b6502f51f6ec2ccab3">More...</a><br /></td></tr>
<tr class="separator:ab53e871487e088b6502f51f6ec2ccab3 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd09e6fa94c79029c5b876ea509edb9 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a64287edfda9bc2abbdafd958b6cfe682">fapply_on_p_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a3dd09e6fa94c79029c5b876ea509edb9">m_apply_p</a></td></tr>
<tr class="memdesc:a3dd09e6fa94c79029c5b876ea509edb9 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="mdescLeft">&#160;</td><td class="mdescRight">function that evaluates effect of action on the P space projection  <a href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a3dd09e6fa94c79029c5b876ea509edb9">More...</a><br /></td></tr>
<tr class="separator:a3dd09e6fa94c79029c5b876ea509edb9 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3e460814c7e8040c9a6fed3de9e3026 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ac8246e59286ac3630c4c80231d6ed172">Verbosity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#ac3e460814c7e8040c9a6fed3de9e3026">m_verbosity</a></td></tr>
<tr class="memdesc:ac3e460814c7e8040c9a6fed3de9e3026 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="mdescLeft">&#160;</td><td class="mdescRight">how much output to print in <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#ad86a191289fae16f2d6df34f3b3ddad4" title="Simplified one-call solver.">solve()</a>  <a href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#ac3e460814c7e8040c9a6fed3de9e3026">More...</a><br /></td></tr>
<tr class="separator:ac3e460814c7e8040c9a6fed3de9e3026 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0d0a39af9d4914c52f317d51f6fd084 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#ae0d0a39af9d4914c52f317d51f6fd084">m_max_iter</a></td></tr>
<tr class="memdesc:ae0d0a39af9d4914c52f317d51f6fd084 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximum number of iterations in <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#ad86a191289fae16f2d6df34f3b3ddad4" title="Simplified one-call solver.">solve()</a>  <a href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#ae0d0a39af9d4914c52f317d51f6fd084">More...</a><br /></td></tr>
<tr class="separator:ae0d0a39af9d4914c52f317d51f6fd084 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b4f79b443412af94b4e9dbd19254bb inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a75b4f79b443412af94b4e9dbd19254bb">m_max_p</a></td></tr>
<tr class="memdesc:a75b4f79b443412af94b4e9dbd19254bb inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximum size of P space  <a href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a75b4f79b443412af94b4e9dbd19254bb">More...</a><br /></td></tr>
<tr class="separator:a75b4f79b443412af94b4e9dbd19254bb inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cd1557340c1bdd64cf98ffdd3e6287a inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a9cd1557340c1bdd64cf98ffdd3e6287a">m_p_threshold</a></td></tr>
<tr class="memdesc:a9cd1557340c1bdd64cf98ffdd3e6287a inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="mdescLeft">&#160;</td><td class="mdescRight">threshold for selecting P space  <a href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a9cd1557340c1bdd64cf98ffdd3e6287a">More...</a><br /></td></tr>
<tr class="separator:a9cd1557340c1bdd64cf98ffdd3e6287a inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ae0ec3d737bc94543b35dc4d0e3558470" name="ae0ec3d737bc94543b35dc4d0e3558470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0ec3d737bc94543b35dc4d0e3558470">&#9670;&nbsp;</a></span>SolverTemplate</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html">molpro::linalg::itsolv::LinearEigensystemDavidson</a>&lt; R, Q, P &gt;::SolverTemplate =  <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html">IterativeSolverTemplate</a>&lt;<a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystem.html">LinearEigensystem</a>, R, Q, P&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae1fcec228a6eaf28bab62636828e5483" name="ae1fcec228a6eaf28bab62636828e5483"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1fcec228a6eaf28bab62636828e5483">&#9670;&nbsp;</a></span>LinearEigensystemDavidson()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html">molpro::linalg::itsolv::LinearEigensystemDavidson</a>&lt; R, Q, P &gt;::LinearEigensystemDavidson </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1ArrayHandlers.html">ArrayHandlers</a>&lt; R, Q, P &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>handlers</em> = <code>std::make_shared&lt;<a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1ArrayHandlers.html">molpro::linalg::itsolv::ArrayHandlers</a>&lt;R,&#160;Q,&#160;P&gt;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1Logger.html">Logger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>logger_</em> = <code>std::make_shared&lt;<a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1Logger.html">Logger</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="accbb21b9dc3c611e7bddd25d0750f972" name="accbb21b9dc3c611e7bddd25d0750f972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accbb21b9dc3c611e7bddd25d0750f972">&#9670;&nbsp;</a></span>construct_residual()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html">molpro::linalg::itsolv::LinearEigensystemDavidson</a>&lt; R, Q, P &gt;::construct_residual </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>roots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#aafd1821a97ea122d56be347e38e90a89">CVecRef</a>&lt; R &gt; &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ab44c7c7dfce88d39d260d1f5c7b70fab">VecRef</a>&lt; R &gt; &amp;&#160;</td>
          <td class="paramname"><em>actions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs residual for given roots provided their parameters and actions. </p>

<p>Implements <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#ac38e5b3cb441edb495c6084a72dbdac0">molpro::linalg::itsolv::IterativeSolverTemplate&lt; LinearEigensystem, R, R, std::map&lt; size_t, typename R::value_type &gt; &gt;</a>.</p>

</div>
</div>
<a id="a57e0b6fcfe3f0711b5c618f0660f2c3c" name="a57e0b6fcfe3f0711b5c618f0660f2c3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57e0b6fcfe3f0711b5c618f0660f2c3c">&#9670;&nbsp;</a></span>eigenvalues()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a4ce4d7778dab44edee1bea7075d7f227">scalar_type</a> &gt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html">molpro::linalg::itsolv::LinearEigensystemDavidson</a>&lt; R, Q, P &gt;::eigenvalues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The calculated eigenvalues of the subspace matrix. </p>

<p>Implements <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystem.html#a6c74967a8caabeeb48d4e5b9a12f42c8">molpro::linalg::itsolv::LinearEigensystem&lt; R, R, std::map&lt; size_t, typename R::value_type &gt; &gt;</a>.</p>

</div>
</div>
<a id="a22ed76de01c073008465614a389df5c3" name="a22ed76de01c073008465614a389df5c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22ed76de01c073008465614a389df5c3">&#9670;&nbsp;</a></span>end_iteration() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html">molpro::linalg::itsolv::LinearEigensystemDavidson</a>&lt; R, Q, P &gt;::end_iteration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ab44c7c7dfce88d39d260d1f5c7b70fab">VecRef</a>&lt; R &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ab44c7c7dfce88d39d260d1f5c7b70fab">VecRef</a>&lt; R &gt; &amp;&#160;</td>
          <td class="paramname"><em>action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Proposes new parameters for the subspace from the preconditioned residuals. </p>
<p >After add_vector solves the subspace problem it returns the new solution and residual. The residual should be preconditioned, i.e. using Davidson method, to accelerate convergence. The updated residual is used in this function to propose new Q space parameters orthonormal to the old space. They are returned in parameters so that corresponding actions can be calculated and used in add_vector in the next iteration.</p>
<p >Every n_reset_D iterations the D space has to be reset. If working set does not cover all solutions than resetting is done over multiple iterations. During this time, there are no deletions from the Q space. This is done by temporarily increasing maximum allowed size of Q space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameters</td><td>output new parameters for the subspace. </td></tr>
    <tr><td class="paramname">residual</td><td>preconditioned residuals. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of significant parameters to calculate the action for </dd></dl>

<p>Implements <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#acfce319e750a3e3a925c489b91dbf7e2">molpro::linalg::itsolv::IterativeSolver&lt; R, R, std::map&lt; size_t, typename R::value_type &gt; &gt;</a>.</p>

</div>
</div>
<a id="aebcf854909acb92f11bb2ea33a596c64" name="aebcf854909acb92f11bb2ea33a596c64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebcf854909acb92f11bb2ea33a596c64">&#9670;&nbsp;</a></span>end_iteration() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html">molpro::linalg::itsolv::LinearEigensystemDavidson</a>&lt; R, Q, P &gt;::end_iteration </td>
          <td>(</td>
          <td class="paramtype">R &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R &amp;&#160;</td>
          <td class="paramname"><em>actions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a1e6b71a13a52437b18b22ace59fcc489">molpro::linalg::itsolv::IterativeSolver&lt; R, R, std::map&lt; size_t, typename R::value_type &gt; &gt;</a>.</p>

</div>
</div>
<a id="a5f3c0bb3e790c82ffebbfbe62d1d3a9c" name="a5f3c0bb3e790c82ffebbfbe62d1d3a9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f3c0bb3e790c82ffebbfbe62d1d3a9c">&#9670;&nbsp;</a></span>end_iteration() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html">molpro::linalg::itsolv::LinearEigensystemDavidson</a>&lt; R, Q, P &gt;::end_iteration </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; R &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; R &gt; &amp;&#160;</td>
          <td class="paramname"><em>action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#af866452579638ebfa72eb5aa4e79cb97">molpro::linalg::itsolv::IterativeSolver&lt; R, R, std::map&lt; size_t, typename R::value_type &gt; &gt;</a>.</p>

</div>
</div>
<a id="a3a0109d914fa9d1c4f40fdc54b835efa" name="a3a0109d914fa9d1c4f40fdc54b835efa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a0109d914fa9d1c4f40fdc54b835efa">&#9670;&nbsp;</a></span>get_hermiticity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html">molpro::linalg::itsolv::LinearEigensystemDavidson</a>&lt; R, Q, P &gt;::get_hermiticity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets hermiticity of kernel, if true than it is hermitian, otherwise it is not. </p>

<p>Implements <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystem.html#a1280ef097d90b4b1f1ed608db76f1071">molpro::linalg::itsolv::LinearEigensystem&lt; R, R, std::map&lt; size_t, typename R::value_type &gt; &gt;</a>.</p>

</div>
</div>
<a id="a053621c2fdae8dcf9c4542ee97888ff7" name="a053621c2fdae8dcf9c4542ee97888ff7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a053621c2fdae8dcf9c4542ee97888ff7">&#9670;&nbsp;</a></span>get_max_size_qspace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html">molpro::linalg::itsolv::LinearEigensystemDavidson</a>&lt; R, Q, P &gt;::get_max_size_qspace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aea95c0b3b85e393fac9d39c931463c03" name="aea95c0b3b85e393fac9d39c931463c03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea95c0b3b85e393fac9d39c931463c03">&#9670;&nbsp;</a></span>get_options()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1Options.html">Options</a> &gt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html">molpro::linalg::itsolv::LinearEigensystemDavidson</a>&lt; R, Q, P &gt;::get_options </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Return all options. This is no different than using getters, but can be used with forward declaration. </p>

<p>Implements <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#ad22826350864db069a44a3a6aa1d15ea">molpro::linalg::itsolv::IterativeSolver&lt; R, R, std::map&lt; size_t, typename R::value_type &gt; &gt;</a>.</p>

</div>
</div>
<a id="a925f70a6fb1a01ede8dd5a6dc0b7dedb" name="a925f70a6fb1a01ede8dd5a6dc0b7dedb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a925f70a6fb1a01ede8dd5a6dc0b7dedb">&#9670;&nbsp;</a></span>get_reset_D()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html">molpro::linalg::itsolv::LinearEigensystemDavidson</a>&lt; R, Q, P &gt;::get_reset_D </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1dabbe4326a656e6cb8f9a1018ceca3d" name="a1dabbe4326a656e6cb8f9a1018ceca3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dabbe4326a656e6cb8f9a1018ceca3d">&#9670;&nbsp;</a></span>get_reset_D_maxQ_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html">molpro::linalg::itsolv::LinearEigensystemDavidson</a>&lt; R, Q, P &gt;::get_reset_D_maxQ_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a262897f82aa5a3ed099646e05ab73372" name="a262897f82aa5a3ed099646e05ab73372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a262897f82aa5a3ed099646e05ab73372">&#9670;&nbsp;</a></span>nonlinear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html">molpro::linalg::itsolv::LinearEigensystemDavidson</a>&lt; R, Q, P &gt;::nonlinear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Report whether the class is a non-linear solver. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p>Implements <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a66ac1625fde41f28ade6cc29f81da931">molpro::linalg::itsolv::IterativeSolver&lt; R, R, std::map&lt; size_t, typename R::value_type &gt; &gt;</a>.</p>

</div>
</div>
<a id="a66a707d2bc8900f8b0478c881ef99cf4" name="a66a707d2bc8900f8b0478c881ef99cf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66a707d2bc8900f8b0478c881ef99cf4">&#9670;&nbsp;</a></span>precondition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html">molpro::linalg::itsolv::LinearEigensystemDavidson</a>&lt; R, Q, P &gt;::precondition </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; R &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; R &gt; &amp;&#160;</td>
          <td class="paramname"><em>action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the Davidson preconditioner. </p>

</div>
</div>
<a id="ac264beb56a500ce1a90edd391ad16b87" name="ac264beb56a500ce1a90edd391ad16b87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac264beb56a500ce1a90edd391ad16b87">&#9670;&nbsp;</a></span>report()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html">molpro::linalg::itsolv::LinearEigensystemDavidson</a>&lt; R, Q, P &gt;::report </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>cout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>endl</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a report to cout output stream. </p>

<p>Implements <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a328990c674d38121f8ebbd5b51a26af0">molpro::linalg::itsolv::IterativeSolver&lt; R, R, std::map&lt; size_t, typename R::value_type &gt; &gt;</a>.</p>

</div>
</div>
<a id="a30cfe987c737da469e7a86a8725586a4" name="a30cfe987c737da469e7a86a8725586a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30cfe987c737da469e7a86a8725586a4">&#9670;&nbsp;</a></span>set_hermiticity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html">molpro::linalg::itsolv::LinearEigensystemDavidson</a>&lt; R, Q, P &gt;::set_hermiticity </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>hermitian</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets hermiticity of kernel. </p>

<p>Implements <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystem.html#a66e43e2aa5f24212eb3562324554ce4f">molpro::linalg::itsolv::LinearEigensystem&lt; R, R, std::map&lt; size_t, typename R::value_type &gt; &gt;</a>.</p>

</div>
</div>
<a id="a5b363a8031dc1b31e0d70783428a5ab9" name="a5b363a8031dc1b31e0d70783428a5ab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b363a8031dc1b31e0d70783428a5ab9">&#9670;&nbsp;</a></span>set_max_size_qspace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html">molpro::linalg::itsolv::LinearEigensystemDavidson</a>&lt; R, Q, P &gt;::set_max_size_qspace </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa46edad2cecdac0a051062435a7188f1" name="aa46edad2cecdac0a051062435a7188f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa46edad2cecdac0a051062435a7188f1">&#9670;&nbsp;</a></span>set_options()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html">molpro::linalg::itsolv::LinearEigensystemDavidson</a>&lt; R, Q, P &gt;::set_options </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Set all spcecified options. This is no different than using setters, but can be used with forward declaration. </p>

<p>Implements <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a7e4e385f3faccb93d44a0e1b070bfa74">molpro::linalg::itsolv::IterativeSolver&lt; R, R, std::map&lt; size_t, typename R::value_type &gt; &gt;</a>.</p>

</div>
</div>
<a id="ab4e8f66aaaa54da8eb41e2a5733ece1d" name="ab4e8f66aaaa54da8eb41e2a5733ece1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4e8f66aaaa54da8eb41e2a5733ece1d">&#9670;&nbsp;</a></span>set_reset_D()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html">molpro::linalg::itsolv::LinearEigensystemDavidson</a>&lt; R, Q, P &gt;::set_reset_D </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the period in iterations for resetting the D space. </p>

</div>
</div>
<a id="a241caed8a5b1e346fc978729892f6260" name="a241caed8a5b1e346fc978729892f6260"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a241caed8a5b1e346fc978729892f6260">&#9670;&nbsp;</a></span>set_reset_D_maxQ_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html">molpro::linalg::itsolv::LinearEigensystemDavidson</a>&lt; R, Q, P &gt;::set_reset_D_maxQ_size </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the maximum size of Q space after resetting the D space. </p>

</div>
</div>
<a id="a8358829492685415686f92b83d7962fc" name="a8358829492685415686f92b83d7962fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8358829492685415686f92b83d7962fc">&#9670;&nbsp;</a></span>set_value_errors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html">molpro::linalg::itsolv::LinearEigensystemDavidson</a>&lt; R, Q, P &gt;::set_value_errors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation class should overload this to set errors in the current values (e.g. change in eigenvalues) </p>

<p>Reimplemented from <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#abf9774c4ebf5d2ac8f670236d417ceb6">molpro::linalg::itsolv::IterativeSolverTemplate&lt; LinearEigensystem, R, R, std::map&lt; size_t, typename R::value_type &gt; &gt;</a>.</p>

</div>
</div>
<a id="ad0cc61ce681e6c9f07a4a869d1caf33d" name="ad0cc61ce681e6c9f07a4a869d1caf33d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0cc61ce681e6c9f07a4a869d1caf33d">&#9670;&nbsp;</a></span>working_set_eigenvalues()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a4ce4d7778dab44edee1bea7075d7f227">scalar_type</a> &gt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html">molpro::linalg::itsolv::LinearEigensystemDavidson</a>&lt; R, Q, P &gt;::working_set_eigenvalues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >The calculated eigenvalues for roots in the working set (eigenvalue problems) or zero (otherwise) </p>

<p>Reimplemented from <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#acab3c3acb752c4c5d093cfe92923eda6">molpro::linalg::itsolv::IterativeSolver&lt; R, R, std::map&lt; size_t, typename R::value_type &gt; &gt;</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a3928db7987c24bda78d24e2f18e6c1d5" name="a3928db7987c24bda78d24e2f18e6c1d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3928db7987c24bda78d24e2f18e6c1d5">&#9670;&nbsp;</a></span>logger</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1Logger.html">Logger</a>&gt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html">molpro::linalg::itsolv::LinearEigensystemDavidson</a>&lt; R, Q, P &gt;::logger</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a54f58e57011e81a3649959d5bf900b59" name="a54f58e57011e81a3649959d5bf900b59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54f58e57011e81a3649959d5bf900b59">&#9670;&nbsp;</a></span>m_dspace_resetter</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1detail_1_1DSpaceResetter.html">detail::DSpaceResetter</a>&lt;Q&gt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html">molpro::linalg::itsolv::LinearEigensystemDavidson</a>&lt; R, Q, P &gt;::m_dspace_resetter</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>resets D space </p>

</div>
</div>
<a id="a9bf051b5bc298da49a9046af0feb0104" name="a9bf051b5bc298da49a9046af0feb0104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bf051b5bc298da49a9046af0feb0104">&#9670;&nbsp;</a></span>m_hermiticity</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html">molpro::linalg::itsolv::LinearEigensystemDavidson</a>&lt; R, Q, P &gt;::m_hermiticity = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>whether the problem is hermitian or not </p>

</div>
</div>
<a id="a26f7dd1a80e4fdda081a2353d3cabb9e" name="a26f7dd1a80e4fdda081a2353d3cabb9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26f7dd1a80e4fdda081a2353d3cabb9e">&#9670;&nbsp;</a></span>m_last_values</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html">molpro::linalg::itsolv::LinearEigensystemDavidson</a>&lt; R, Q, P &gt;::m_last_values</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The values from the previous iteration. </p>

</div>
</div>
<a id="a482db55c4914b82cedcbbb3190c519f8" name="a482db55c4914b82cedcbbb3190c519f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a482db55c4914b82cedcbbb3190c519f8">&#9670;&nbsp;</a></span>m_max_size_qspace</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html">molpro::linalg::itsolv::LinearEigensystemDavidson</a>&lt; R, Q, P &gt;::m_max_size_qspace = std::numeric_limits&lt;int&gt;::max()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>maximum size of Q space </p>

</div>
</div>
<a id="a4f8b13cbdbd2dc723312d0d640c31917" name="a4f8b13cbdbd2dc723312d0d640c31917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f8b13cbdbd2dc723312d0d640c31917">&#9670;&nbsp;</a></span>m_resetting_in_progress</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html">molpro::linalg::itsolv::LinearEigensystemDavidson</a>&lt; R, Q, P &gt;::m_resetting_in_progress = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>whether D space resetting is in progress </p>

</div>
</div>
<a id="abc0bdc92047dafddad208549048eef54" name="abc0bdc92047dafddad208549048eef54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc0bdc92047dafddad208549048eef54">&#9670;&nbsp;</a></span>propose_rspace_norm_thresh</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html">molpro::linalg::itsolv::LinearEigensystemDavidson</a>&lt; R, Q, P &gt;::propose_rspace_norm_thresh = 1e-10</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>vectors with norm less than threshold can be considered null. </p>

</div>
</div>
<a id="a3b96209972872ffece08f78a2c747c5a" name="a3b96209972872ffece08f78a2c747c5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b96209972872ffece08f78a2c747c5a">&#9670;&nbsp;</a></span>propose_rspace_svd_thresh</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html">molpro::linalg::itsolv::LinearEigensystemDavidson</a>&lt; R, Q, P &gt;::propose_rspace_svd_thresh = 1e-12</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >the smallest singular value in the subspace that can be allowed when constructing the working set. Smaller singular values will lead to deletion of parameters from the Q space </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacemolpro.html">molpro</a></li><li class="navelem"><a class="el" href="namespacemolpro_1_1linalg.html">linalg</a></li><li class="navelem"><a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html">itsolv</a></li><li class="navelem"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html">LinearEigensystemDavidson</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
