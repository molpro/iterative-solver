!> @examples OptimizeExampleF.F90
!> This is an examples of simplest use of the Optimize framework for iterative
!> solution of non-linear equations.
!> With forced=.false., the examples makes stationary a normalised quadratic form, so is equivalent to finding an eigenvector.
!> With forced=.true., the examples makes stationary a quadratic form plus a linear force.
module QuasiNewton_Examples
  USE Iterative_Solver_Problem
  private
  type, extends(Problem), public :: forced_t
  contains
    procedure, pass :: residual => forced_residual
    procedure, pass :: diagonals => forced_diagonals
  end type forced_t

  type, extends(Problem), public :: quadratic_t
  contains
    procedure, pass :: residual => quadratic_residual
  end type quadratic_t

  INTEGER, PARAMETER, public :: n = 2
  DOUBLE PRECISION, DIMENSION (n, n), public :: m

contains

  function forced_residual(this, parameters, residuals) result(e)
    class(forced_t), intent(in) :: this
    double precision :: e
    double precision, intent(in), dimension(:, :) :: parameters
    double precision, intent(inout), dimension(:, :) :: residuals
    m = 1; DO i = 1, n; m(i, i) = 3 * i;
    END DO
    residuals = MATMUL(m, parameters)
    write (6,*) 'forced_residual parameters=',parameters
    write (6,*) 'forced_residual actions=',residuals
    e = 0.5 * dot_product(parameters(:, 1), residuals(:, 1)) - sum(parameters(:, 1))
    residuals = residuals - 1
    write (6,*) 'forced_residual residuals=',residuals
  end function forced_residual

  logical function forced_diagonals(this,d)
    class(forced_t), intent(in) :: this
    double precision, intent(inout), dimension(:) :: d
    do i=1,n
      d(i) = 3*i
    end do
    forced_diagonals = .true.
    end function forced_diagonals

  function quadratic_residual(this, parameters, residuals) result(value)
    class(quadratic_t), intent(in) :: this
    double precision :: value
    double precision, intent(in), dimension(:, :) :: parameters
    double precision, intent(inout), dimension(:, :) :: residuals
    m = 1; DO i = 1, n; m(i, i) = 3 * i;
    END DO
    residuals = MATMUL(m, parameters)
    e = dot_product(parameters(:,1), residuals(:,1)) / dot_product(parameters(:,1), parameters(:,1))
    residuals = (residuals - e * parameters) / dot_product(parameters(:,1), parameters(:,1))
  end function quadratic_residual

end module QuasiNewton_Examples

PROGRAM QuasiNewton_Example
  USE Iterative_Solver
  USE QuasiNewton_Examples
  IMPLICIT NONE
  interface
    subroutine mpi_init() BIND (C, name = 'mpi_init')
    end subroutine mpi_init
    subroutine mpi_finalize() BIND (C, name = 'mpi_finalize')
    end subroutine mpi_finalize
    !    function mpi_comm_global() BIND (C, name = 'mpi_comm_global')
    !      use iso_c_binding, only: c_int64_t
    !      integer(c_int64_t) mpi_comm_global
    !    end function mpi_comm_global
  end interface
!  INTEGER, PARAMETER :: n = 2
!  DOUBLE PRECISION, DIMENSION (n, n) :: m
  DOUBLE PRECISION, DIMENSION (n) :: c, g
  DOUBLE PRECISION :: e, e0
  INTEGER :: i, j
  LOGICAL :: converged
  LOGICAL, PARAMETER :: forced = .TRUE.
  type(forced_t) :: problem
  call mpi_init
  PRINT *, 'Fortran binding of IterativeSolver::IOptimize'
  m = 1; DO i = 1, n; m(i, i) = 3 * i;
  END DO
  c = 0; if (.not. forced) c(1) = 1
  CALL Iterative_Solver_Optimize_Initialize(n, thresh = 1d-9, verbosity = 1, algorithm = "BFGS", options = "max_size_qspace=7")
  CALL Iterative_Solver_Solve(c,g, problem)
  CALL Iterative_Solver_Finalize
  CALL Iterative_Solver_Optimize_Initialize(n, thresh = 1d-9, verbosity = 1, algorithm = "BFGS", options = "max_size_qspace=7")
  c = 0; if (.not. forced) c(1) = 1
  e0 = m(1, 1)
  DO i = 1, 30
    g = MATMUL(m, c)
    if (forced) then
      e = 0.5 * dot_product(c, g) - sum(c)
      g = g - 1
    else
      e = dot_product(c, g) / dot_product(c, c)
      g = (g - e * c) / dot_product(c, c)
    end if
    write (6, *) 'function value ', e
    write (6, *) 'c ', c
    write (6, *) 'g ', g
    IF (Iterative_Solver_Add_Vector(c, g, value = e).gt.0) THEN
      if (forced) then
        g = g / [(m(j, j), j = 1, n)]
      else
        g = g / ([(m(j, j), j = 1, n)] - e + 1d-15) &
          + (sum([(c(j) * g(j), j = 1, n)]) / sum([(c(j)**2, j = 1, n)])) * c &
            / ([(m(j, j), j = 1, n)] - e + 1d-15)
      end if
    END IF
    converged = Iterative_Solver_End_Iteration(c, g) .eq.0
    IF (converged) EXIT
  END DO
  if (.not. forced) c = c / sqrt(dot_product(c, c))
  PRINT *, 'solution ', c(1:MIN(n, 10))
  CALL Iterative_Solver_Finalize
  call mpi_finalize
END PROGRAM QuasiNewton_Example
